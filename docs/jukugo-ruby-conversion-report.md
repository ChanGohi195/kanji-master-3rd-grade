# 熟語ルビ変換プロジェクト総括レポート

## 概要

本レポートは、小学3年生向け漢字学習アプリにおける熟語ルビ表示の問題解決過程を記録したものである。データ構造設計がアプリケーションの品質を決定づけることを実証した事例として、今後の開発資産とする。

---

## 1. 問題の発見

### 1.1 現象

例文データにおいて、熟語のルビが不適切に表示される問題が発生。

```
入力: 悪魔[あくま]は こわい。
期待: 悪[あく]魔[ま]は こわい。
実際: 悪魔[あくま] → 最後の「魔」にのみルビが付く
```

### 1.2 根本原因

ルビの二重性問題:
1. **枠に紐づくルビ**: 学習対象の漢字に対する読み指導
2. **熟語に紐づくルビ**: 熟語全体の読み方

この二つが混在し、パーサーが熟語を1文字ずつ処理する際に、ルビが最後の漢字にのみ付与される設計上の欠陥があった。

### 1.3 標準規格の調査

W3Cルビマークアップ仕様を調査し、3つのルビ形式を確認:

| 形式 | 用途 | 例 |
|------|------|-----|
| Mono-ruby | 1文字ずつ | `東[ひがし]` |
| Group-ruby | グループ単位 | `今日[きょう]` |
| **Jukugo-ruby** | 熟語（推奨） | `東[とう]京[きょう]` |

**結論**: W3C推奨のJukugo-ruby形式（漢字ごとに個別ルビ）への変換が必要。

---

## 2. アプローチの変遷

### 2.1 第一アプローチ: モーラベース自動分割（失敗）

**仮説**: 日本語の音韻規則に基づき、読みを自動的に漢字ごとに分割できる。

**実装**:
```javascript
// モーラパターンで分割を試みる
const moraPattern = /[あ-ん]ー?|[ぁぃぅぇぉゃゅょっ]/g;
```

**結果**: 79件のエラー（成功率 約85%）

**失敗例**:
```
暗記[あんき] → 暗[あ]記[んき]  // 誤り
正解: 暗[あん]記[き]
```

**教訓**: 日本語音韻論の複雑さを過小評価。以下の規則が必要:
- 撥音「ん」は前の漢字に属する
- 促音「っ」は前の漢字に属する
- 長音「う」は前の漢字に属する
- 連濁・連声の処理

### 2.2 第二アプローチ: 音読み辞書ベース（部分成功）

**仮説**: 単一漢字の音読み辞書を用意し、組み合わせで熟語の読みを検証できる。

**実装**:
```javascript
const onReadingDict = {
  '悪': 'あく', '安': 'あん', '暗': 'あん', ...
};

function splitOnReadingByDict(kanjiChars, reading) {
  const readings = kanjiChars.map(k => onReadingDict[k]);
  if (readings.join('') === reading) {
    return kanjiChars.map((k, i) => ({ kanji: k, reading: readings[i] }));
  }
  return null;
}
```

**結果**: 成功率 30.4%（187件成功 / 429件失敗）

**失敗パターン**:
1. 辞書に未登録の漢字（236件不足）
2. 濁音変化（三階 → さんがい、銀河 → ぎんが）
3. 促音化（学級 → がっきゅう、特急 → とっきゅう）
4. 訓読み熟語（荷物 → にもつ、本屋 → ほんや）
5. 4文字以上の複合語

### 2.3 第三アプローチ: 熟語レベル辞書（成功）

**仮説**: 熟語を個別に辞書登録する方が、言語学的規則をコード化するより確実で保守しやすい。

**実装**:
```javascript
const compoundDict = {
  // 促音化
  '学級': ['がっ', 'きゅう'],
  '特急': ['とっ', 'きゅう'],

  // 濁音変化
  '三階': ['さん', 'がい'],
  '銀河': ['ぎん', 'が'],

  // 訓読み・混合
  '荷物': ['に', 'もつ'],
  '本屋': ['ほん', 'や'],

  // ひらがな混じり
  '乗り物': ['の', 'もの'],
  '真ん中': ['ま', 'なか'],

  // 熟字訓（分割不可）
  '童歌': null,
};
```

**結果**: 成功率 99.8%（624件成功 / 1件分割不可）

---

## 3. 辞書設計の原則

### 3.1 階層構造

```
┌─────────────────────────────────────────────┐
│            熟語辞書（compoundDict）          │
│  - 特殊読み・濁音・促音・訓読み・混合読み    │
│  - 最優先で参照                              │
├─────────────────────────────────────────────┤
│            音読み辞書（onReadingDict）        │
│  - 単一漢字の標準音読み                      │
│  - 熟語辞書にない場合のフォールバック        │
└─────────────────────────────────────────────┘
```

### 3.2 熟語辞書のカテゴリ

| カテゴリ | 例 | 辞書登録形式 |
|----------|-----|-------------|
| 熟字訓 | 童歌[わらべうた] | `'童歌': null` |
| 4文字以上 | 家族旅行 | `['か', 'ぞく', 'りょ', 'こう']` |
| 促音化 | 学級 | `['がっ', 'きゅう']` |
| 濁音変化 | 三階 | `['さん', 'がい']` |
| 訓読み | 荷物 | `['に', 'もつ']` |
| ひらがな混じり | 乗り物 | `['の', 'もの']` |

### 3.3 ひらがな混じり熟語の処理

漢字間にひらがなが挟まる構造（`乗り物`、`真ん中`）は特殊処理が必要:

```javascript
// 正規表現パターン（ひらがな混じりも対象）
/([\u4E00-\u9FFF][\u4E00-\u9FFF\u3040-\u309Fっ]+)\[([^\]]+)\]/g

// 変換結果
乗り物[のりもの] → 乗[の]り物[もの]
真ん中[まんなか] → 真[ま]ん中[なか]
真っ白[まっしろ] → 真[ま]っ白[しろ]
```

---

## 4. 技術的知見

### 4.1 日本語音韻論の複雑さ

| 現象 | 説明 | 例 |
|------|------|-----|
| 撥音 | 「ん」は前の漢字に属する | 暗記 → あん+き |
| 促音 | 「っ」は前の漢字に属する | 発表 → はっ+ぴょう |
| 連濁 | 後続語の語頭が濁音化 | 三+階 → さん+がい |
| 連声 | 音が変化して連結 | 反+応 → はん+のう |
| 長音 | 「う」が前に属する | 横断 → おう+だん |

### 4.2 アルゴリズム vs 辞書

| 観点 | アルゴリズム | 辞書 |
|------|-------------|------|
| 初期コスト | 高（言語学的知識） | 中（登録作業） |
| 保守性 | 低（例外処理の追加） | 高（エントリ追加） |
| 正確性 | 例外に弱い | 登録分は100% |
| 拡張性 | 規則の追加が困難 | 単純追加 |
| 透明性 | ブラックボックス化 | 明示的 |

**結論**: 有限集合（小学校配当漢字・熟語）では辞書ベースが優位。

### 4.3 正規表現設計の注意点

```javascript
// NG: 連続漢字のみ対象
/([\u4E00-\u9FFF]{2,})\[([^\]]+)\]/

// OK: ひらがな混じりも対象
/([\u4E00-\u9FFF][\u4E00-\u9FFF\u3040-\u309Fっ]+)\[([^\]]+)\]/
```

処理フロー全体で一貫したパターンを使用すること（hasJukugoチェックと変換処理で不一致があり問題が発生）。

---

## 5. 成果物

### 5.1 変換スクリプト

- **ファイル**: `scripts/convert-jukugo-ruby-v2.js`
- **機能**: examples.json内の熟語ルビをJukugo-ruby形式に変換
- **辞書**: 音読み辞書（約300漢字）+ 熟語辞書（約150熟語）

### 5.2 変換統計

| 項目 | 件数 |
|------|------|
| 総例文数 | 1,000 |
| 変換成功 | 624 |
| 変換不要（単一漢字） | 375 |
| 分割不可（熟字訓） | 1 |
| **成功率** | **99.8%** |

---

## 6. 教訓と推奨事項

### 6.1 設計原則

1. **辞書構造 = データベース設計**: 漢字・熟語アプリでは辞書設計がアプリの心臓。初期設計に十分な時間を投資すべき。

2. **標準規格の早期調査**: W3Cルビ仕様のような標準を先に調査することで、手戻りを防げる。

3. **アルゴリズムより辞書**: 有限集合を扱う場合、複雑なアルゴリズムより明示的な辞書登録が保守しやすい。

### 6.2 他学年への展開

本変換ロジックは以下の手順で他学年に適用可能:

1. `onReadingDict`に該当学年の漢字を追加
2. `compoundDict`に該当学年の特殊熟語を追加
3. スクリプト実行、失敗リスト確認、辞書追加の反復

### 6.3 将来の拡張

- 辞書のJSON外部化（`kanji-readings.json`, `compound-readings.json`）
- バリデーションスクリプトの整備
- 他学年との辞書共有メカニズム

---

## 7. 追加修正：読み問題UIの不整合

ルビ変換完了後の動作確認で、読み問題（`bunsho/yomi`）に複数の設計不整合が発見された。

### 7.1 熟語の問い方とデータ構造の不整合

**発見された問題**:
```
問い: 「七福神」の読みは？
正解: 「フク」
表示: 七・福・神 すべてに枠
```

ユーザーは熟語全体の読みを問われていると認識するが、正解は対象漢字（福）の読みのみ。

**根本原因**:

データ構造には「どの漢字を問うか」の情報が存在する（`character`フィールド）が、UIがそれを適切に表示していなかった。

| フィールド | 値 | 役割 |
|-----------|-----|------|
| `character` | 福 | 学習対象の漢字 |
| `targetWord` | 七福神 | 熟語全体 |
| `reading` | フク | 対象漢字の読み |

**修正内容**:

1. 問いの文言を修正:
```svelte
// Before
「{targetWord}」の よみかたは？

// After
「{targetWord}」の「{character}」の よみかたは？
```

2. 強調表示を対象漢字のみに限定:
```svelte
// Before: 熟語全体をハイライト
<VerticalSentence targetWord={targetWord} ... />

// After: 対象漢字のみハイライト
<VerticalSentence targetKanji={character} ... />
```

### 7.2 選択肢の4択保証

**発見された問題**:

168件の漢字でユニーク読みが4未満のため、選択肢が2〜3択になるケースがあった。

**修正内容**:

同じ漢字の読みが不足する場合、他の漢字の読みから補完:

```javascript
// 3つに満たない場合、他の漢字の読みから補完
if (wrongChoices.length < 3) {
  const allReadings = allExamples.flatMap(k => k.examples.map(e => e.reading));
  // ... 補完ロジック
}
```

### 7.3 選択肢の表示上重複

**発見された問題**:

同じ選択肢が複数表示される。例:
- `わる.い` と `わる.く` は異なる`reading`だが、表示上は両方「わる」
- 同じ漢字に`アン`が5回出現し、選択肢に複数の「アン」が並ぶ

**根本原因**:

選択肢生成時は`reading`（送り仮名付き）で重複チェックしていたが、表示時は`getStemReading`で送り仮名を除去していた。

**修正内容**:

表示上の読み（送り仮名除去後）で重複チェック:

```javascript
const correctStem = getStemReading(correct);
const usedStems = new Set<string>([correctStem]);

for (const r of candidates) {
  const stem = getStemReading(r);
  if (!usedStems.has(stem)) {
    usedStems.add(stem);
    wrongChoices.push(r);
  }
}
```

### 7.4 教訓

1. **データ構造とUIの整合性**: データに情報があっても、UIが適切に利用しなければ意味がない。設計時にUI側の表示要件を明確にすべき。

2. **表示層と処理層の一貫性**: 表示時に変換（送り仮名除去）を行う場合、処理層（選択肢生成）でも同じ変換を適用して整合性を保つ。

3. **エッジケースの網羅**: 「ユニーク読みが4未満の漢字」のような境界条件を事前に洗い出し、テストケースとして確保すべき。

---

## 8. 参考資料

- [W3C Ruby Markup](https://www.w3.org/TR/ruby/)
- [文化庁 常用漢字表](https://www.bunka.go.jp/kokugo_nihongo/sisaku/joho/joho/kijun/naikaku/kanji/)
- [小学校学習指導要領 国語](https://www.mext.go.jp/a_menu/shotou/new-cs/youryou/syo/koku.htm)

---

**作成日**: 2026-02-02
**更新日**: 2026-02-02（追加修正分を追記）
**プロジェクト**: kanji-master-3rd-grade
**バージョン**: v2.1
